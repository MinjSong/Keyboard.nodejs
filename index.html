<!DOCTYPE html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>
    <style>
        @font-face {
            font-family: "ManropeWeight";
            src: url("Manrope-VariableFont_wght.ttf")
            /* src: url("https://fonts.googleapis.com/css2?family=Manrope&display=swap"); */
        }
        /* @import url("https://fonts.googleapis.com/css2?family=Manrope:wght@200&display=swap"); */
        body {
            /* font-family: "IBM Plex Sans Roman", Times; */
            font-family: 'ManropeWeight';
            font-size: 10vw;
            margin: 1%;
        }
        p {
            margin:0;
            padding:0;
        }
        span {
            float:left;
        }
        .cursor {
            border-bottom: 2px solid black;
        }
    </style>
</head>

<body>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Socket is the library we use to connect this webpage to the server in node js
        var socket = io();

        const maxBufferSize = 5; // how many input values are buffered per letter
        let inputBuffer = {};
        let currentLetter; // letter currently selected by user

        const interval = 100; // how often the buffer is checked
        let last = new Date(); // last time data was received from socket
        let flushed = false; // used to flush character from stream into sentence
        let sentenceElements = []; // html elements of each letter in sentence
        let cursorToggle = false; // toggles when cursor blinks

        let chatElement; // html element that holds letters
        let currentLetterElement; // html element for currently selected letter

        function createLetterElement() {
            currentLetterElement = createSpan('');
            currentLetterElement.parent(chatElement);
            currentLetterElement.style('color', '#ff0000');
            currentLetterElement.addClass('cursor');
        }

        let points;
        let bounds;
        let letter = 'm';
        let font;

        let wobblePressure = 0;

        function preload() {
            font = loadFont('SuisseIntlMono-Thin.otf',function(err, f) {
                if (err) {
                console.log(err);
                } else {
                font = f;
                }
            });
        }

        // p5.js setup
        function setup() {
            background(255);

            chatElement = createDiv();
            chatElement.style("width", "100%");
            chatElement.style("float", "left");
            chatElement.style("height", "200px")
            createLetterElement();

            createCanvas(windowWidth, windowHeight);
        }

        // p5.js draw
        function draw() {

            background(255);

            if (currentLetter == null) {
                return;
            };

            const fontSize = 10;
            points = font.textToPoints(currentLetter, 0, 0, fontSize, {
                sampleFactor: 50,
                simplifyThreshold: 0
            });
            bounds = font.textBounds(currentLetter, 0, 0, fontSize);
            
            // background(255);
            // stroke(0,5);
            // strokeWeight(0.2);
            fill(0);
            translate(width / 2 - bounds.w / 2, height / 2 + bounds.h / 2);
            beginShape();
            for (let i = 0; i < points.length; i++) {
                let p = points[i];
                let horizontalMoveSpeed = 1000; // larger = slower
                let horizontalMoveDistance = 8; // large = wider
                let waviness = 5 // larger = more wavey
                let size = 100;
                let input = millis();
                input = map(wobblePressure, 90, 400, 0, 20000);
                let x = p.x * size / bounds.w + sin((waviness * -p.y / bounds.w) + input / horizontalMoveSpeed) * horizontalMoveDistance;
                let y = p.y * size / bounds.h + cos((10 * -p.x / bounds.h) + input / 200);
                vertex(x, y);
            }
            endShape(CLOSE);
        }

        const currentLetterInputInterval = setInterval(function() {
            if (currentLetter in inputBuffer) {
                // handle backspace
                if ((new Date() - last) > interval && !flushed && sentenceElements.length > 0 && currentLetter == '\b') {
                    sentenceElements.pop().remove();
                    flushed = true;
                }

                // handle space
                if (!flushed && currentLetter == '\\s') {
                    if ((new Date() - last) > interval) {
                        currentLetterElement.removeClass("cursor");
                        currentLetterElement.html('&nbsp;');
                        sentenceElements.push(currentLetterElement);
                        flushed = true;
                        createLetterElement();
                    }
                    return;
                }

                // remove NaN from buffer
                const nonNaNBuffer = inputBuffer[currentLetter].pressure.filter(a => a);
                // select max
                const maxOfNonNaNBuffer = nonNaNBuffer.reduce(function(a,b) { return a > b ? a : b });
                // filter out max
                const filteredOutMax = nonNaNBuffer.filter(a => nonNaNBuffer.length == 1 || a != maxOfNonNaNBuffer);
                // get the avg
                const avg = filteredOutMax.reduce(function(acc, val) { return acc + val; }, 0) / filteredOutMax.length;

                const pressure = avg;
                wobblePressure = pressure;

                const MANROPE_WEIGHT_MIN = 200;
                const MANROPE_WEIGHT_MAX = 800;

                // add paragraph element
                const fontWeight = map(pressure,300, 90, MANROPE_WEIGHT_MIN, MANROPE_WEIGHT_MAX);

                console.log(pressure,fontWeight);

                // add weight to currently typed letter
                currentLetterElement.style('font-weight', pressure);
                currentLetterElement.style('font-variation-settings', "'wght' "+fontWeight);
                
                // if new current letter then set as white space
                if (!flushed) {
                    currentLetterElement.html(currentLetter);
                } else {
                    currentLetterElement.html('&nbsp;');
                }

                // decide whether to flush character to sentence
                let elapsedTime = (new Date() - last) > interval;
                if (elapsedTime) {
                    if (!flushed) {
                        flushed = true;
                        currentLetterElement.removeClass("cursor");
                        // add letter to chat window
                        sentenceElements.push(currentLetterElement);
                        createLetterElement();
                    }
                }
            }
        }, interval);

        const cursorInterval = setInterval(function() {
            if (cursorToggle) {
                currentLetterElement.addClass("cursor");
            } else {
                currentLetterElement.removeClass("cursor");
            }
            cursorToggle = !cursorToggle;
        }, 500);
        
        socket.on('data', (data) => {

            // console.log(data);

            // used to flush character to sentence
            flushed = false;

            // set date last received
            last = new Date();

            // populate buffer
            if (!(data.letter in inputBuffer)) {
                inputBuffer[data.letter] = {
                    "index": -1,
                    "pressure": new Array(maxBufferSize)
                }
            }

            // handle new letter input
            const newLetterInput = data.letter != currentLetter;
            if (newLetterInput && currentLetter != null) {
                inputBuffer[currentLetter].pressure = new Array(maxBufferSize);
            }

            currentLetter = data.letter;

            // update current letter buffer
            inputBuffer[data.letter].index = (inputBuffer[data.letter].index + 1) % maxBufferSize;
            inputBuffer[data.letter].pressure[inputBuffer[data.letter].index] = data.pressure;
        });

    </script>

    <script>


    </script>
</body>
