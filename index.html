<!DOCTYPE html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>
    <style>
       
        @font-face {
            font-family: "ManropeWeight";
            src: url("Manrope-VariableFont_wght.ttf")
            /* src: url("https://fonts.googleapis.com/css2?family=Manrope&display=swap"); */
        }
        /* @import url("https://fonts.googleapis.com/css2?family=Manrope:wght@200&display=swap"); */
        body{
            margin-left : 0px;
            margin-right : 0px;
        }
        
        h1 {
            font-family: 'ManropeWeight';
            background-color: white;
            border-bottom: 1px solid rgb(76, 187, 122);
            height: 20px;
            letter-spacing : 1px;
            font-size: 9pt; 
            color: rgb(76, 187, 122);
            padding-bottom : 5px;
            padding-left : 10px;
            margin-left : 0px;
            margin-right : opx;
        }

        h2 {
            font-family: 'ManropeWeight';
            margin-left : 0px;
            margin-right : 0px;
            margin-top : 30;
        }

        p {
            margin:0;
            padding:0;
        }
        span {
            float:left;  
        }
        .cursor {
            border-bottom: 2px solid black;
        }

  
    </style>
</head>

<body>
    <h1> CROISSANT </h1>
    <h2>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Socket is the library we use to connect this webpage to the server in node js
        var socket = io();

        const maxBufferSize = 5; // how many input values are buffered per letter
        let inputBuffer = {};
        let currentLetter; // letter currently selected by user

        const interval = 100; // how often the buffer is checked
        let last = new Date(); // last time data was received from socket
        let flushed = false; // used to flush character from stream into sentence
        let sentenceElements = []; // html elements of each letter in sentence
        let cursorToggle = false; // toggles when cursor blinks

        let chatElement; // html element that holds letters
        let currentLetterElement; // html element for currently selected letter

        function createLetterElement() {
            currentLetterElement = createSpan('');
            currentLetterElement.parent(chatElement);
            currentLetterElement.style('color', '#ff0000');
            currentLetterElement.addClass('cursor');
        }


        let points;
        let bounds;
        let letter = '';
        let font;

        let wobblePressure = 0;
        let totalPressure; 

        const lettersToPoints = {};

        function preload() {
            font = loadFont('Manrope-VariableFont_wght.ttf',function(err, f) {
                if (err) {
                    console.log(err);
                } else {
                    font = f;
                }
            });
        }

        // p5.js setup
        function setup() {
            background(255);

            chatElement = createDiv();
            chatElement.style("width", "90%");
            chatElement.style("float", "left");
            chatElement.style("height", "100px");
            chatElement.style("display", "none");
            createLetterElement();

            createCanvas(windowWidth, windowHeight);
            // load all letter points and bounds
            const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');
            const fontSize = 10;
            for (idx in alphabet) {
                const letter = alphabet[idx];
                points = font.textToPoints(letter, 0, 0, fontSize, {
                    sampleFactor: 50,
                    simplifyThreshold: 0
                });
                bounds = font.textBounds(letter, 0, 0, fontSize);
                lettersToPoints[letter] = {points, bounds};
            }
        }
    
        let lastLetter;
        const p5Letters = [];
        const size = 100;
        const spacing = 6;

        const letterWidth = 50;

        // p5.js draw
        function draw() {

            background(255);

            // const gridWidth = windowWidth / size - 1;
            // const gridHeight = windowHeight / size - 1;

            // for (let i = 0; i < gridHeight; i++) {
            //     push();
            //     for (let j = 0; j < gridWidth; j++) {
            //         rect(0, 0, size, size);
            //         translate(size, 0);
            //     }
            //     pop();
            //     translate(0, size);
            // }

            if (currentLetter == null) {
                return;
            };

            translate(0, size);
            

            if (currentLetter != lastLetter) {
                if (currentLetter == '\b') {
                    p5Letters.pop();
                } else {
                    p5Letters.push({currentLetter, wobblePressure});
                }
            } else {
                const l = p5Letters[p5Letters.length-1];
                if (l !== undefined) {
                    p5Letters[p5Letters.length-1].wobblePressure = wobblePressure;
                }
            }

            lastLetter = currentLetter;

            let colCount = 0;

            for (i in p5Letters) {
                const l = p5Letters[i].currentLetter;
                if (l == '\\s') {
                    translate(i == 0 ? 0 : 15*2, 0);
                } else {
                    const p = lettersToPoints[l].points;
                    const b = lettersToPoints[l].bounds;
                    drawLetterShape(l, p, b, p5Letters[i].wobblePressure);
                    let xTranslate = b.w * 15;
                    if ('il'.split("").includes(l)) {
                        xTranslate *= 4;
                    }
                    if ('zemowb'.split("").includes(l)) {
                        xTranslate -= 15;
                    }
                    translate(xTranslate, 0);
                }
            }

        }

        // p5 letter
        const drawLetterShape = function(letter, points, bounds, wobblePressure) {

            const horizontalMoveSpeed = 900; // larger = slower
            const horizontalMoveDistance = 7; // large = wider
            let waviness = 4// larger = more wavey

            if (letter == 'i') {
                waviness = .3;
            }
            if (letter == 'l') {
                waviness = .3;
            }
            if (letter == 'j') {
                waviness = 1;
            }
            if (letter == 'r') {
                waviness = 2;
            }
            if (letter == 't') {
                waviness = 3;
            }

            let from = color(76, 187, 122);
            let to = color(200);
            let c = lerpColor(from, to, wobblePressure/1024*2);
            fill(c);
            stroke(0,200);
            strokeWeight(0.05);
            beginShape();
            for (let i = 0; i < points.length; i++) {
                let p = points[i];
                let input = map(wobblePressure, 90, 400, 0, 20000);
                let x = p.x * 10 + sin((waviness * -p.y / bounds.w) + input / horizontalMoveSpeed) * horizontalMoveDistance;
                let y = p.y * 10 + cos((10 * -p.y / bounds.h) + input / 200);
                vertex(x, y);
            }
            endShape(CLOSE);
        }

        const currentLetterInputInterval = setInterval(function() {
            if (currentLetter in inputBuffer) {
                // handle backspace
                if ((new Date() - last) > interval && !flushed && sentenceElements.length > 0 && currentLetter == '\b') {
                    sentenceElements.pop().remove();
                    flushed = true;
                }

                // handle space
                if (!flushed && currentLetter == '\\s') {
                    if ((new Date() - last) > interval) {
                        currentLetterElement.removeClass("cursor");
                        currentLetterElement.html('&nbsp;');
                        sentenceElements.push(currentLetterElement);
                        flushed = true;
                        createLetterElement();
                    }
                    return;
                }

                // remove NaN from buffer
                const nonNaNBuffer = inputBuffer[currentLetter].pressure.filter(a => a);
                // select max
                const maxOfNonNaNBuffer = nonNaNBuffer.reduce(function(a,b) { return a > b ? a : b });
                // filter out max
                const filteredOutMax = nonNaNBuffer.filter(a => nonNaNBuffer.length == 1 || a != maxOfNonNaNBuffer);
                // get the avg
                const avg = filteredOutMax.reduce(function(acc, val) { return acc + val; }, 0) / filteredOutMax.length;

                const pressure = avg;
                wobblePressure = pressure;

                const MANROPE_WEIGHT_MIN = 200;
                const MANROPE_WEIGHT_MAX = 800;

                // add paragraph element
                const fontWeight = map(pressure,300, 90, MANROPE_WEIGHT_MIN, MANROPE_WEIGHT_MAX);

                // add weight to currently typed letter
                currentLetterElement.style('font-weight', pressure);
                currentLetterElement.style('font-variation-settings', "'wght' "+fontWeight);
                
                // if new current letter then set as white space
                if (!flushed) {
                    currentLetterElement.html(currentLetter);
                } else {
                    currentLetterElement.html('&nbsp;');
                }

                // decide whether to flush character to sentence
                let elapsedTime = (new Date() - last) > interval;
                if (elapsedTime) {
                    if (!flushed) {
                        flushed = true;
                        currentLetterElement.removeClass("cursor");
                        // add letter to chat window
                        sentenceElements.push(currentLetterElement);
                        createLetterElement();
                    }
                }
            }
        }, interval);

        const cursorInterval = setInterval(function() {
            if (cursorToggle) {
                currentLetterElement.addClass("cursor");
            } else {
                currentLetterElement.removeClass("cursor");
            }
            cursorToggle = !cursorToggle;
        }, 500);
        
        socket.on('data', (data) => {

            // used to flush character to sentence
            flushed = false;

            // set date last received
            last = new Date();

            // populate buffer
            if (!(data.letter in inputBuffer)) {
                inputBuffer[data.letter] = {
                    "index": -1,
                    "pressure": new Array(maxBufferSize)
                }
            }

            // handle new letter input
            const newLetterInput = data.letter != currentLetter;
            if (newLetterInput && currentLetter != null) {
                inputBuffer[currentLetter].pressure = new Array(maxBufferSize);
            }

            currentLetter = data.letter;

            // update current letter buffer
            inputBuffer[data.letter].index = (inputBuffer[data.letter].index + 1) % maxBufferSize;
            inputBuffer[data.letter].pressure[inputBuffer[data.letter].index] = data.pressure;
        });

    </script>
    </h2>
    <script>


    </script>
</body>
