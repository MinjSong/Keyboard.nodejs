<!DOCTYPE html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>
    <style>
       
        @font-face {
            font-family: "ManropeWeight";
            src: url("Manrope-VariableFont_wght.ttf")
            /* src: url("https://fonts.googleapis.com/css2?family=Manrope&display=swap"); */
        }
        /* @import url("https://fonts.googleapis.com/css2?family=Manrope:wght@200&display=swap"); */
        body{
            margin-left : 0px;
            margin-right : 0px;
        }
        
        h1 {
            font-family: 'ManropeWeight';
            background-color: white;
            border-bottom: 1px solid rgb(76, 187, 122);
            height: 20px;
            letter-spacing : 1px;
            font-size: 9pt; 
            color: rgb(76, 187, 122);
            padding-bottom : 5px;
            padding-left : 10px;
            margin-left : 0px;
            margin-right : opx;
        }

        h2 {
            font-family: 'ManropeWeight';
            margin-left : 0px;
            margin-right : 0px;
            margin-top : 30;
        }

        p {
            margin:0;
            padding:0;
        }
        span {
            float:left;  
        }
        .cursor {
            border-bottom: 2px solid black;
        }

  
    </style>
</head>

<body>
    <h1> CROISSANT </h1>
    <h2>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Socket is the library we use to connect this webpage to the server in node js
        var socket = io();

        const maxBufferSize = 5; // how many input values are buffered per letter
        let inputBuffer = {};
        let currentLetter; // letter currently selected by user

        const interval = 100; // how often the buffer is checked
        let last = new Date(); // last time data was received from socket
        let flushed = false; // used to flush character from stream into sentence
        let sentenceElements = []; // html elements of each letter in sentence
        let cursorToggle = false; // toggles when cursor blinks

        let chatElement; // html element that holds letters
        let currentLetterElement; // html element for currently selected letter

        function createLetterElement() {
            currentLetterElement = createSpan('');
            currentLetterElement.parent(chatElement);
            currentLetterElement.style('color', '#ff0000');
            currentLetterElement.addClass('cursor');
        }


        let points;
        let bounds;
        let letter = '';
        let font;

        let wobblePressure = 0;
        let totalPressure; 

        const lettersToPoints = {};

        function preload() {
            font = loadFont('Manrope-VariableFont_wght.ttf',function(err, f) {
                if (err) {
                    console.log(err);
                } else {
                    font = f;
                }
            });
        }

        // p5.js setup
        function setup() {
            background(255);

            chatElement = createDiv();
            chatElement.style("width", "90%");
            chatElement.style("float", "left");
            chatElement.style("height", "100px");
            chatElement.style("display", "none");
            createLetterElement();

            createCanvas(windowWidth, windowHeight);

            // load all letter points and bounds
            const alphabet = 'abcdefghijklmnopqrstuvwxyz '.split('');
            const fontSize = 10;
            for (idx in alphabet) {
                const letter = alphabet[idx];
                points = font.textToPoints(letter, 0, 0, fontSize, {
                    sampleFactor: 50,
                    simplifyThreshold: 0
                });
                bounds = font.textBounds(letter, 0, 0, fontSize);
                lettersToPoints[letter] = {points, bounds};
            }
        }
    
        let p5Letters = [];
        const sentences = [];
        const size = 100;
        const spacing = 6;
        const letterWidth = 50;
        let yOffset = 0;

        setInterval(function() {
            if (currentLetter == undefined) {
                return;
            }
            // remove NaN from buffer
            const nonNaNBuffer = inputBuffer[currentLetter].pressure.filter(a => a);
            // select max
            const maxOfNonNaNBuffer = nonNaNBuffer.reduce(function(a,b) { return a > b ? a : b });
            // filter out max
            const filteredOutMax = nonNaNBuffer.filter(a => nonNaNBuffer.length == 1 || a != maxOfNonNaNBuffer);
            // get the avg
            const avg = filteredOutMax.reduce(function(acc, val) { return acc + val; }, 0) / filteredOutMax.length;

            const pressure = avg;
            wobblePressure = pressure;

            let elapsedTime = (new Date() - last) > interval;

            if (!flushed && elapsedTime) {
                if (currentLetter == '\n') {
                    sentences.push(p5Letters);
                    p5Letters = [];
                } else if (currentLetter == '\b') {
                    p5Letters.pop();
                } else if (currentLetter == '\\s') {
                    p5Letters.push({"currentLetter":" ", wobblePressure});
                    p5Letters.push({"currentLetter":"", wobblePressure});
                } else {
                    p5Letters.push({"currentLetter":currentLetter, wobblePressure});
                    p5Letters.push({"currentLetter":"", wobblePressure});
                }
                flushed = true;
            }
        }, interval);

        // p5.js draw
        function draw() {
            background(255);
            translate(0, size);

            if (p5Letters.length > 0) {
                p5Letters[p5Letters.length-1].wobblePressure = wobblePressure;
            }

            push();
            renderSentences(sentences);
            pop();

            translate(0, sentences.length * size);
            renderLetters(p5Letters, false);

            if (currentLetter == null || currentLetter == '\n' || currentLetter == '\b' || currentLetter == '\\s') {
                return;
            }

            // render current letter
            if (!flushed) {
                const p = lettersToPoints[currentLetter].points;
                const b = lettersToPoints[currentLetter].bounds;
                push();
                drawLetterShape(currentLetter, p, b, wobblePressure);
                pop();
            }
        }

        const renderSentences = function(sentences) {
            for (i in sentences) {
                const sentence = sentences[i];
                push();
                translate(0, i * size);
                renderLetters(sentence, true);
                pop();
            }
        }

        const renderLetters = function(letters, pushing) {
            if (pushing) push();
            for (i in letters) {
                const l = letters[i].currentLetter;
                if (l == "") {
                    continue;
                }
                if (l == '\\s') {
                    translate(i == 0 ? 0 : 15*2, 0);
                } else {
                    const p = lettersToPoints[l].points;
                    const b = lettersToPoints[l].bounds;
                    drawLetterShape(l, p, b, letters[i].wobblePressure);
                    let xTranslate = b.w * 15;
                    if ('il'.split("").includes(l)) {
                        xTranslate *= 4;
                    }
                    if ('zemowbwcky'.split("").includes(l)) {
                        xTranslate -= 15;
                    }
                    if ('w' == l) {
                        xTranslate -= 20;
                    }
                    translate(xTranslate, 0);
                }
            }
            if (pushing) pop();
        }

        // p5 letter
        const drawLetterShape = function(letter, points, bounds, wobblePressure) {
            const horizontalMoveSpeed = 900; // larger = slower
            const horizontalMoveDistance = 7; // large = wider
            let waviness = 4// larger = more wavey

            if (letter == 'i') {
                waviness = .3;
            }
            if (letter == 'l') {
                waviness = .3;
            }
            if (letter == 'j') {
                waviness = 1;
            }
            if (letter == 'r') {
                waviness = 2;
            }
            if (letter == 't') {
                waviness = 3;
            }

            let from = color(76, 187, 122);
            let to = color(200);
            let c = lerpColor(from, to, wobblePressure/1024*2);
            fill(c);
            stroke(0,200);
            strokeWeight(0.05);
            beginShape();
            for (let i = 0; i < points.length; i++) {
                let p = points[i];
                let input = map(wobblePressure, 90, 400, 0, 20000);
                let x = p.x * 10 + sin((waviness * -p.y / bounds.w) + input / horizontalMoveSpeed) * horizontalMoveDistance;
                let y = p.y * 10 + cos((10 * -p.y / bounds.h) + input / 200);
                vertex(x, y);
            }
            endShape(CLOSE);
        }

        socket.on('data', (data) => {

            // used to flush character to sentence
            flushed = false;

            // set date last received
            last = new Date();

            // populate buffer
            if (!(data.letter in inputBuffer)) {
                inputBuffer[data.letter] = {
                    "index": -1,
                    "pressure": new Array(maxBufferSize)
                }
            }

            // handle new letter input
            const newLetterInput = data.letter != currentLetter;
            if (newLetterInput && currentLetter != null) {
                inputBuffer[currentLetter].pressure = new Array(maxBufferSize);
            }

            currentLetter = data.letter;

            // update current letter buffer
            inputBuffer[data.letter].index = (inputBuffer[data.letter].index + 1) % maxBufferSize;
            inputBuffer[data.letter].pressure[inputBuffer[data.letter].index] = data.pressure;
        });

    </script>
    </h2>
    <script>


    </script>
</body>
